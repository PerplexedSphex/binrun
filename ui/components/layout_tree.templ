package components

import (
	"fmt"
)

// LayoutNode mirrors platform.LayoutNode to avoid import cycle
type LayoutNode struct {
	// For leaf nodes
	Subscription string `json:"subscription,omitempty"`

	// For command nodes
	Command  string         `json:"command,omitempty"`
	Script   string         `json:"script,omitempty"`
	Defaults map[string]any `json:"defaults,omitempty"`

	// For binary splits
	Split  string      `json:"split,omitempty"`
	At     string      `json:"at,omitempty"`
	First  *LayoutNode `json:"first,omitempty"`
	Second *LayoutNode `json:"second,omitempty"`

	// For even splits
	Direction string        `json:"direction,omitempty"`
	Items     []*LayoutNode `json:"items,omitempty"`
}

// PanelLayout mirrors platform.PanelLayout
type PanelLayout struct {
	Panels map[string]*LayoutNode `json:"panels"`
}

// NodeType returns the type of this layout node
func (n *LayoutNode) NodeType() string {
	if n.Subscription != "" {
		return "leaf"
	}
	if n.Command != "" {
		return "command"
	}
	if n.Split == "horizontal" || n.Split == "vertical" {
		return "binary"
	}
	if len(n.Split) > 5 && n.Split[:5] == "even-" {
		return "even"
	}
	return "unknown"
}

// LayoutTree renders the entire panel layout
templ LayoutTree(layout *PanelLayout, panelName string) {
	if layout == nil || layout.Panels == nil {
		// No layout, render nothing
		<div id={panelName + "-panel-content"}></div>
	} else if node, ok := layout.Panels[panelName]; ok && node != nil {
		<div id={panelName + "-panel-content"} class="layout-root">
			@renderLayoutNode(node, panelName, "root")
		</div>
	} else {
		// Panel not defined in layout
		<div id={panelName + "-panel-content"}></div>
	}
}

// renderLayoutNode recursively renders a layout node
templ renderLayoutNode(node *LayoutNode, panelName string, path string) {
	switch node.NodeType() {
	case "leaf":
		@renderLeafNode(node, panelName, path)
	case "command":
		@renderCommandNode(node, panelName, path)
	case "binary":
		@renderBinaryNode(node, panelName, path)
	case "even":
		@renderEvenNode(node, panelName, path)
	}
}

// renderLeafNode renders a subscription container
templ renderLeafNode(node *LayoutNode, panelName string, path string) {
	<div class="layout-leaf" data-path={path}>
		@SubscriptionContainer(node.Subscription)
	</div>
}

// renderCommandNode renders a command form
templ renderCommandNode(node *LayoutNode, panelName string, path string) {
	<div class="layout-command" data-path={path}>
		@CommandForm(node.Command, node.Script, node.Defaults)
	</div>
}

// renderBinaryNode renders a binary split
templ renderBinaryNode(node *LayoutNode, panelName string, path string) {
	<div 
		class={"layout-split", "layout-split-" + node.Split}
		data-path={path}
		style={getBinarySplitStyle(node)}
	>
		<div class="layout-split-first">
			@renderLayoutNode(node.First, panelName, path + "-first")
		</div>
		<div class="layout-split-second">
			@renderLayoutNode(node.Second, panelName, path + "-second")
		</div>
	</div>
}

// renderEvenNode renders an even split
templ renderEvenNode(node *LayoutNode, panelName string, path string) {
	<div 
		class={"layout-even", "layout-even-" + node.Direction}
		data-path={path}
		style={getEvenSplitStyle(node)}
	>
		for i, item := range node.Items {
			<div class="layout-even-item">
				@renderLayoutNode(item, panelName, fmt.Sprintf("%s-item%d", path, i))
			</div>
		}
	</div>
}

// Helper functions for generating CSS styles

func getBinarySplitStyle(node *LayoutNode) string {
	if node.Split == "horizontal" {
		// horizontal = top/bottom split
		switch node.At {
		case "1/3":
			return "grid-template-rows: 1fr 2fr;"
		case "2/3":
			return "grid-template-rows: 2fr 1fr;"
		case "1/4":
			return "grid-template-rows: 1fr 3fr;"
		case "3/4":
			return "grid-template-rows: 3fr 1fr;"
		default: // "1/2"
			return "grid-template-rows: 1fr 1fr;"
		}
	} else {
		// vertical = left/right split
		switch node.At {
		case "1/3":
			return "grid-template-columns: 1fr 2fr;"
		case "2/3":
			return "grid-template-columns: 2fr 1fr;"
		case "1/4":
			return "grid-template-columns: 1fr 3fr;"
		case "3/4":
			return "grid-template-columns: 3fr 1fr;"
		default: // "1/2"
			return "grid-template-columns: 1fr 1fr;"
		}
	}
}

func getEvenSplitStyle(node *LayoutNode) string {
	count := len(node.Items)
	if node.Direction == "horizontal" {
		// horizontal = row of items
		return fmt.Sprintf("grid-template-columns: repeat(%d, 1fr);", count)
	} else {
		// vertical = column of items
		return fmt.Sprintf("grid-template-rows: repeat(%d, 1fr);", count)
	}
} 